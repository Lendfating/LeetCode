#!/usr/bin/python  
# -*- coding: utf-8 -*- 

"""
# soluction

参看：http://zh.wikipedia.org/zh/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0
该问题可以用一个数学公示表达出来，下面简单证明一下：
首先，先把所有的树形结构抽象成01序列。参照LeetCode里面的把树形结构序列化表示方式。
中序遍历二叉树，如果某个子节点为空，则写为 #， 这样就可以唯一确定树形结构。
然后再抽想到树的中序遍历过程，遇到一个节点直接入栈（1），如果该节点的左子树为空，则弹栈（0）并输出栈顶元素，
然后再遍历其右子树，如果右子树遍历完，则继续弹栈（0），以返回当前结点的父结点。因此，如果把0当做 #， 把1当做有效数值，
则这个过程会跟LeetCode中将二叉树序列化的方式相同。因此，每一种树结构对应一种独特的10串。且1和0的个数都是n，且在任意时刻，n(1)>=n(0)
(注意上述过程不要用前序和后续过程去理解，不然讲不通)

下面求解 n个0和n个1组成的10串中，任意前缀都满足N(1)>=N(0)条件的串的个数。
首先，n个0和n个1组成的串共有 C(2n, n) 个
然后，再从其中去除不满足条件的。
    对于一个不满足条件的串，找其第一个不满足条件的位置2m+1, 前面有 m+1个 “0”和 m个 “1”.
    然后，其后会有 n-m-1 个“0”， 和 n-m个“1”，如果我们将后面（2m+1位之后）的0->1, 1->0，
    则得到的这个新串是一个共有n+1个“0” 和 n-1个“1”的新串。新串与上述不满足条件的串一一对应。(反之亦然)
    因此，要求不满足条件的串的个数，即求 n+1个0和n-1个1组成的串的个数，答案为 C(2n, n+1)个。
    
因此，满足条件的01串的总数为 C(2n, n)-C(2n, n+1) = 1/(n+1)*C(2n, n)

"""
class Solution:
    # @return an integer
    def numTrees(self, n):
        nums = [0]*(n+1)
        nums[0] = 1
        for i in xrange(1, n+1):
            for k in xrange(i):
                nums[i] += nums[k]*nums[i-k-1]
        return nums[n]
    
    # @return an integer
    def numTrees1(self, n):
        # use catalan number formula
        # f(n) = 1/(n+1)*C(2n, n) = 2n*(2n-1)*...*(n+2)/n!
        #      = II ((n+i)/i)
        #      2<=i<=n
        #      = 2*(2n-2)/(n+1)*f(n-1)
        result = 1
        for i in xrange(2, n+1):
            result *= (n+i)/i
        return result
        
        

if __name__ == '__main__':
    pass
